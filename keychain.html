<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Keychain Generator — Text & Braille (SVG + STL)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!--
README
- Purpose: Single-file web app to preview (SVG) and export (STL) a keychain.
- Styles:
  • Text: Arial text with an offset “bubble” (preview via stroke; STL via raster→mesh).
  • Braille: UEB Grade 1 (uncontracted) with rounded-rect base + domed (spherical-cap) dots.
- Input rule: one word OR two words separated by exactly one ASCII space.
  Hyphens/apostrophes may appear inside a word. Anything else ⇒ error; preview/export disabled.
- Units: mm. 1 mm = 3.7795275591 px @96 DPI (preview DPI is fixed; don’t change it).
- Resolution:
  • STL mesh resolution strictly follows state.mmPerPixel (no auto-scaling). Default 0.2 mm/px.
    To increase smoothness, use ?mmPerPixel=0.1 (bigger meshes).
- Fixes:
  • Export uses for-loops to append triangles (no spread operator) → avoids call stack limits.
  • Text export sizing is DPI-independent (computed in mm).
  • Braille dots are centered within the rounded rectangle; STL and preview align exactly.
- Accessibility: Proper labels, aria-live error messages, keyboard focusable preview region.
- Advanced settings are present but hidden; you can re-expose them later.
-->
<style>
  :root {
    --bg: #0b0c10; --panel: #15171c; --ink: #f2f5f7; --muted: #a6b0bb;
    --accent: #5ac8fa; --ok: #34c759; --err: #ff453a; --bubble: #dde3ea;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--ink); background: var(--bg);
    display: grid; grid-template-columns: 380px 1fr; gap: 0;
  }
  aside { padding: 16px 18px; background: var(--panel); overflow: auto; border-right: 1px solid #101218; }
  main { position: relative; overflow: hidden; display: grid; grid-template-rows: auto 1fr; }
  h1 { font-size: 18px; margin: 0 0 10px; color: var(--ink); }
  .muted { color: var(--muted); font-size: 12px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 6px; margin-bottom: 12px; }
  label { font-size: 14px; color: var(--ink); }
  input[type="text"], select {
    width: 100%; padding: 8px 10px; border: 1px solid #2a2e36; border-radius: 8px; background: #0e1117; color: var(--ink);
  }
  input[aria-invalid="true"] { border-color: var(--err); outline: none; }
  .btnbar { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
  button {
    border: 1px solid #263241; background: #111821; color: var(--ink);
    padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600;
  }
  button.ok { border-color: #175f3c; background: #0e281c; color: #bff0cc; }
  button[disabled] { opacity: 0.5; cursor: not-allowed; }
  button:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
  .card { background: #0f141b; border: 1px solid #111821; border-radius: 12px; padding: 12px; margin-bottom: 14px; }
  .toolbar { padding: 10px; display: flex; gap: 12px; align-items: center; border-bottom: 1px solid #101218; background:#0f141b; }
  .toolbar .value { font-variant-numeric: tabular-nums; }
  #previewWrap { position: relative; overflow: auto; background: #0b0f15; border-top: 1px solid #0c0f14; }
  svg { display: block; margin: 0; background: transparent; }
  .errbox {
    background: rgba(255,69,58,.12); border: 1px solid rgba(255,69,58,.5); color: #ffd3d0;
    padding: 8px 10px; border-radius: 8px; font-size: 13px; margin-top: 8px;
  }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .adv-hidden[hidden] { display: none !important; } /* keep advanced hidden */
</style>
</head>
<body>
  <aside aria-label="Controls">
    <h1>Keychain Generator</h1>
    <p class="muted" id="unitHelp">Units: <b>mm</b>. 1&nbsp;mm = <span class="mono">3.7795275591</span>&nbsp;px @96&nbsp;DPI.</p>

    <form id="form" role="form" aria-describedby="unitHelp">
      <div class="card" role="group" aria-labelledby="lbl-keychain-text">
        <div id="lbl-keychain-text" class="muted" style="margin-bottom:6px;">Keychain text</div>

        <div class="row">
          <label for="keychainText">Enter one word, or two words separated by exactly one space</label>
          <input
            id="keychainText"
            name="keychainText"
            type="text"
            aria-describedby="keychainRules keychainError"
            aria-invalid="false"
            autocomplete="off"
            inputmode="text"
            placeholder="e.g., Tay or Tay Bear"
            pattern="^[A-Za-z0-9][A-Za-z0-9'’-]*(?: [A-Za-z0-9][A-Za-z0-9'’-]*)?$"
            />
          <div id="keychainRules" class="muted small">
            Hyphens/apostrophes allowed inside a word. No leading/trailing spaces. Exactly one space allowed only when providing two words.
          </div>
          <div id="keychainError" class="errbox" role="alert" aria-live="assertive" style="display:none;"></div>
        </div>

        <div class="row">
          <label for="renderStyle">Style</label>
          <select id="renderStyle" aria-describedby="styleNote">
            <option value="text">Text</option>
            <option value="braille">Braille</option>
          </select>
          <div id="styleNote" class="muted small">
            Braille uses UEB Grade&nbsp;1, rounded-rect base, and domed dots.
          </div>
        </div>
      </div>

      <div class="btnbar" style="margin-top:12px;">
        <button id="btnReset" type="button" title="Reset all values">Reset</button>
        <button id="btnDownload" type="button" class="ok" title="Export STL">Download STL</button>
      </div>

      <!-- Advanced settings (hidden, still honored) -->
      <details id="adv" class="adv-hidden" hidden aria-hidden="true">
        <summary>Advanced settings</summary>
        <div class="adv-body">
          <div class="row"><label for="facedownMode"><input id="facedownMode" type="checkbox" /> Facedown mode (text at 0.1&nbsp;mm)</label></div>
          <div class="row"><label for="fontSize">Font size (mm)</label><input id="fontSize" type="number" min="2" step="0.5" value="15" /></div>
          <div class="row"><label for="r">Bubble offset radius (mm)</label><input id="r" type="number" min="0" step="0.5" value="4" /></div>
          <div class="row"><label for="thickness">Base thickness (mm)</label><input id="thickness" type="number" min="0.1" step="0.1" value="2" /></div>
          <div class="row"><label for="textThickness">Text thickness (mm)</label><input id="textThickness" type="number" min="0.1" step="0.1" value="1" /></div>
          <div class="row"><label for="line2Offset">Line 2 X offset (mm)</label><input id="line2Offset" type="number" step="0.5" value="0" /></div>
          <div class="row"><label for="line2VerticalOffset">Line 2 Y offset (mm)</label><input id="line2VerticalOffset" type="number" step="0.5" value="15" /></div>
          <div class="row"><label for="keychainHoleSize">Hole diameter (mm)</label><input id="keychainHoleSize" type="number" min="0.1" step="0.5" value="4" /></div>
          <div class="row"><label for="keychainHoleOffset">Hole X offset (mm)</label><input id="keychainHoleOffset" type="number" step="0.5" value="1" /></div>
          <div class="row"><label for="boxWidth">Optional box width (mm)</label><input id="boxWidth" type="number" min="0" step="0.5" value="0" /></div>
          <div class="row"><label for="boxHeight">Optional box height (mm)</label><input id="boxHeight" type="number" min="0" step="0.5" value="0" /></div>
          <div class="row"><label for="boxXOffset">Box X offset (mm)</label><input id="boxXOffset" type="number" step="0.5" value="0" /></div>
          <div class="row"><label for="boxYOffset">Box Y offset (mm)</label><input id="boxYOffset" type="number" step="0.5" value="-30" /></div>
          <div class="row"><label for="mmPerPixel">Raster cell size (mm, export)</label><input id="mmPerPixel" type="number" min="0.001" step="0.01" value="0.2" /></div>
        </div>
      </details>
      <input type="hidden" id="fontFamily" value="Arial" />
    </form>
  </aside>

  <main>
    <div class="toolbar" aria-live="polite">
      <div class="muted small">Preview (SVG)</div>
      <div class="muted small" style="margin-left:auto;">
        Canvas size: <span id="sz" class="value mono">—</span>
      </div>
    </div>
    <div id="previewWrap" tabindex="0" aria-label="Design preview">
      <svg id="svg" width="1200" height="600" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Keychain preview">
        <g id="gRoot" transform="translate(80,160)">
          <g id="bg"></g>
          <g id="shapes"></g>
          <g id="txt"></g>
        </g>
      </svg>
    </div>
  </main>

<script>
/* -------------------------- Constants -------------------------- */
const DPI = 96; // preview scale only - DO NOT CHANGE
const PX_PER_MM = DPI / 25.4;

const DEFAULTS = {
  line2Offset: 0,
  line2VerticalOffset: 15,     // Text style: line 2 below line 1
  facedownMode: false,         // ignored in Braille
  fontFamily: "Arial",         // fixed for Text style
  fontSize: 15,                // mm (Text)
  r: 4,                        // bubble offset radius (Text)
  thickness: 2,
  textThickness: 1,            // Text style only
  keychainHoleSize: 4,
  keychainHoleOffset: 1,
  boxWidth: 0,
  boxHeight: 0,
  boxXOffset: 0,
  boxYOffset: -30,
  mmPerPixel: 0.2,             // FIXED resolution: no auto-scaling
  renderStyle: "text"          // "text" | "braille"
};

/* Braille config (BANA-friendly) */
const BRAILLE_CFG = {
  dotDiameter: 1.5,        // mm
  dotHeight:   0.5,        // mm (spherical cap height)
  col:         2.5,        // mm center-to-center between columns
  row:         2.5,        // mm center-to-center between rows
  cellPitch:   6.0,        // mm horizontal advance per cell
  linePitch:   10.0,       // mm vertical distance between line origins
  pad:         4.0,        // mm padding around content in base
  cornerR:     6.0,        // mm rounded-rect corner radius
  domeSegs:    12,         // around
  domeRings:   6           // apex->base rings
};

/* -------------------------- Elements -------------------------- */
const $ = sel => document.querySelector(sel);
const inputText = $('#keychainText');
const errBox = $('#keychainError');
const btnDownload = $('#btnDownload');
const renderStyleSel = $('#renderStyle');
const hiddenFontFamily = $('#fontFamily');

/* Hidden advanced controls (kept for future use) */
const advEls = {
  facedownMode: $('#facedownMode'),
  fontSize: $('#fontSize'),
  r: $('#r'),
  thickness: $('#thickness'),
  textThickness: $('#textThickness'),
  line2Offset: $('#line2Offset'),
  line2VerticalOffset: $('#line2VerticalOffset'),
  keychainHoleSize: $('#keychainHoleSize'),
  keychainHoleOffset: $('#keychainHoleOffset'),
  boxWidth: $('#boxWidth'),
  boxHeight: $('#boxHeight'),
  boxXOffset: $('#boxXOffset'),
  boxYOffset: $('#boxYOffset'),
  mmPerPixel: $('#mmPerPixel'),
};

/* -------------------------- State -------------------------- */
let state = {...DEFAULTS};
let lastValid = null;

/* -------------------------- Helpers -------------------------- */
const mm2px = mm => mm * PX_PER_MM;
const px2mm = px => px / PX_PER_MM;
const esc = s => encodeURIComponent(String(s));

function setError(msg) {
  inputText.setAttribute('aria-invalid', 'true');
  errBox.textContent = msg;
  errBox.style.display = '';
  btnDownload.disabled = true;
}
function clearError() {
  inputText.setAttribute('aria-invalid', 'false');
  errBox.textContent = '';
  errBox.style.display = 'none';
  btnDownload.disabled = false;
}

/* -------------------------- Input parsing -------------------------- */
// EXACT rules: one word OR two words with exactly one ASCII space.
// Allowed inside words: letters/digits/hyphen/apostrophe.
const WORD_RE = /^[A-Za-z0-9][A-Za-z0-9'’-]*$/;
function parseKeychainText(s) {
  if (/\s/.test(s) && s.indexOf(' ') === -1) {
    return { ok:false, reason:'Use exactly one ASCII space between two words (or no space for one word).' };
  }
  if (s !== '' && (s.startsWith(' ') || s.endsWith(' '))) {
    return { ok:false, reason:'No leading or trailing spaces.' };
  }
  const parts = s.split(' ');
  if (parts.length === 1) {
    const w = parts[0];
    if (w.length === 0) return { ok:false, reason:'Enter one word, or two words separated by exactly one space.' };
    if (!WORD_RE.test(w)) return { ok:false, reason:'Invalid characters. Use letters/numbers and optional hyphens/apostrophes inside the word.' };
    return { ok:true, name:w, second:false };
  }
  if (parts.length === 2) {
    const [w1, w2] = parts;
    if (w1.length===0 || w2.length===0) return { ok:false, reason:'Exactly one space between two non-empty words.' };
    if (!WORD_RE.test(w1) || !WORD_RE.test(w2)) return { ok:false, reason:'Invalid characters in one of the words.' };
    return { ok:true, name:w1, line2:w2, second:true };
  }
  return { ok:false, reason:'Only one or two words allowed with exactly one space between when using two.' };
}

/* -------------------------- Advanced controls (hidden) -------------------------- */
function initAdvancedFromState() {
  advEls.facedownMode.checked = state.facedownMode;
  advEls.fontSize.value = state.fontSize;
  advEls.r.value = state.r;
  advEls.thickness.value = state.thickness;
  advEls.textThickness.value = state.textThickness;
  advEls.line2Offset.value = state.line2Offset;
  advEls.line2VerticalOffset.value = state.line2VerticalOffset;
  advEls.keychainHoleSize.value = state.keychainHoleSize;
  advEls.keychainHoleOffset.value = state.keychainHoleOffset;
  advEls.boxWidth.value = state.boxWidth;
  advEls.boxHeight.value = state.boxHeight;
  advEls.boxXOffset.value = state.boxXOffset;
  advEls.boxYOffset.value = state.boxYOffset;
  advEls.mmPerPixel.value = state.mmPerPixel;
}
function readAdvancedIntoState() {
  state.facedownMode = advEls.facedownMode.checked;
  state.fontSize = Number(advEls.fontSize.value) || DEFAULTS.fontSize;
  state.r = Math.max(0, Number(advEls.r.value) || DEFAULTS.r);
  state.thickness = Math.max(0.1, Number(advEls.thickness.value) || DEFAULTS.thickness);
  state.textThickness = Math.max(0.1, Number(advEls.textThickness.value) || DEFAULTS.textThickness);
  state.line2Offset = Number(advEls.line2Offset.value) || DEFAULTS.line2Offset;
  state.line2VerticalOffset = Number(advEls.line2VerticalOffset.value) || DEFAULTS.line2VerticalOffset;
  state.keychainHoleSize = Math.max(0.1, Number(advEls.keychainHoleSize.value) || DEFAULTS.keychainHoleSize);
  state.keychainHoleOffset = Number(advEls.keychainHoleOffset.value) || DEFAULTS.keychainHoleOffset;
  state.boxWidth = Math.max(0, Number(advEls.boxWidth.value) || DEFAULTS.boxWidth);
  state.boxHeight = Math.max(0, Number(advEls.boxHeight.value) || DEFAULTS.boxHeight);
  state.boxXOffset = Number(advEls.boxXOffset.value) || DEFAULTS.boxXOffset;
  state.boxYOffset = Number(advEls.boxYOffset.value) || DEFAULTS.boxYOffset;
  // Respect mmPerPixel exactly (no autoscale, no upper clamp)
  state.mmPerPixel = Math.max(0.001, Number(advEls.mmPerPixel.value) || DEFAULTS.mmPerPixel);
}

/* -------------------------- URL Sync -------------------------- */
function paramsToQuery() {
  const o = { keychainText: inputText.value, ...state };
  const pairs = [];
  for (const k in o) pairs.push(`${k}=${esc(o[k])}`);
  return '?' + pairs.join('&');
}
function parseQuery() {
  const q = new URLSearchParams(location.search);
  if (q.has('keychainText')) inputText.value = q.get('keychainText');
  for (const k in DEFAULTS) {
    if (q.has(k)) {
      const t = typeof DEFAULTS[k];
      state[k] = (t==='boolean') ? (q.get(k)==='true')
                : (t==='number') ? Number(q.get(k))
                : q.get(k);
    }
  }
}

/* -------------------------- Braille mapping -------------------------- */
// bit positions: dot1=1<<0, dot2=1<<1, dot3=1<<2, dot4=1<<3, dot5=1<<4, dot6=1<<5
const D = n => 1 << (n-1);
const BRAILLE_MAP = {
  a: D(1), b: D(1)|D(2), c: D(1)|D(4), d: D(1)|D(4)|D(5), e: D(1)|D(5),
  f: D(1)|D(2)|D(4), g: D(1)|D(2)|D(4)|D(5), h: D(1)|D(2)|D(5),
  i: D(2)|D(4), j: D(2)|D(4)|D(5),
  k: D(1)|D(3), l: D(1)|D(2)|D(3), m: D(1)|D(3)|D(4), n: D(1)|D(3)|D(4)|D(5),
  o: D(1)|D(3)|D(5), p: D(1)|D(2)|D(3)|D(4), q: D(1)|D(2)|D(3)|D(4)|D(5),
  r: D(1)|D(2)|D(3)|D(5), s: D(2)|D(3)|D(4), t: D(2)|D(3)|D(4)|D(5),
  u: D(1)|D(3)|D(6), v: D(1)|D(2)|D(3)|D(6), w: D(2)|D(4)|D(5)|D(6),
  x: D(1)|D(3)|D(4)|D(6), y: D(1)|D(3)|D(4)|D(5)|D(6), z: D(1)|D(3)|D(5)|D(6),
  hyphen: D(3)|D(6), apostrophe: D(3), number: D(3)|D(4)|D(5)|D(6), capital: D(6)
};
function isLetter(ch){ return /[A-Za-z]/.test(ch); }
function isDigit(ch){ return /[0-9]/.test(ch); }

function encodeBrailleCells(word) {
  const out = [];
  let i=0;
  while (i<word.length) {
    const ch = word[i];
    if (isDigit(ch)) {
      out.push(BRAILLE_MAP.number);
      while (i<word.length && isDigit(word[i])) {
        const d = word[i];
        const letter = (d==='0') ? 'j' : String.fromCharCode('a'.charCodeAt(0) + (parseInt(d)-1));
        out.push(BRAILLE_MAP[letter]);
        i++;
      }
      continue;
    }
    if (isLetter(ch)) {
      const lower = ch.toLowerCase();
      if (ch !== lower) out.push(BRAILLE_MAP.capital);
      out.push(BRAILLE_MAP[lower] || 0);
      i++;
      continue;
    }
    if (ch === '-' ) { out.push(BRAILLE_MAP.hyphen); i++; continue; }
    if (ch === "'" || ch === "’") { out.push(BRAILLE_MAP.apostrophe); i++; continue; }
    i++; // validator prevents other chars
  }
  return out;
}

/* Layout Braille: base + dots + centering shift + global bbox (includes tab) */
function layoutBraille(parsed) {
  const cfg = BRAILLE_CFG;
  const a = cfg.dotDiameter/2;

  const lines = [];
  const line1 = encodeBrailleCells(parsed.name);
  lines.push(line1);
  if (parsed.second) lines.push(encodeBrailleCells(parsed.line2));

  const widths = lines.map(arr => arr.length * cfg.cellPitch);
  const contentW = Math.max(...widths, 0);
  const contentTop = -a;
  const contentBottom = ((lines.length>1 ? cfg.linePitch : 0) + (2*cfg.row)) + a;

  const base = {
    x: -cfg.pad,
    y: contentTop - cfg.pad,
    w: contentW + 2*cfg.pad,
    h: (contentBottom - contentTop) + 2*cfg.pad
  };

  const dots = [];
  const colX = [0, cfg.col];
  const rowY = [0, cfg.row, 2*cfg.row];

  for (let li=0; li<lines.length; li++) {
    const yOrigin = li * cfg.linePitch;
    const arr = lines[li];
    for (let ci=0; ci<arr.length; ci++) {
      const mask = arr[ci];
      const xOrigin = ci * cfg.cellPitch;
      if (mask & (1<<0)) dots.push({x: xOrigin + colX[0], y: yOrigin + rowY[0]});
      if (mask & (1<<1)) dots.push({x: xOrigin + colX[0], y: yOrigin + rowY[1]});
      if (mask & (1<<2)) dots.push({x: xOrigin + colX[0], y: yOrigin + rowY[2]});
      if (mask & (1<<3)) dots.push({x: xOrigin + colX[1], y: yOrigin + rowY[0]});
      if (mask & (1<<4)) dots.push({x: xOrigin + colX[1], y: yOrigin + rowY[1]});
      if (mask & (1<<5)) dots.push({x: xOrigin + colX[1], y: yOrigin + rowY[2]});
    }
  }

  // Center dots inside the rounded rect (ignore tab for centering)
  let shift = { x: 0, y: 0 };
  if (dots.length) {
    let minX = +Infinity, maxX = -Infinity, minY = +Infinity, maxY = -Infinity;
    for (const d of dots) {
      if (d.x < minX) minX = d.x; if (d.x > maxX) maxX = d.x;
      if (d.y < minY) minY = d.y; if (d.y > maxY) maxY = d.y;
    }
    const dotCx = (minX + maxX) / 2;
    const dotCy = (minY + maxY) / 2;
    const baseCx = base.x + base.w / 2;
    const baseCy = base.y + base.h / 2;
    shift.x = baseCx - dotCx;
    shift.y = baseCy - dotCy;
  }

  // Global bbox used to size the raster canvas for export (includes tab & hole)
  const outerR = (state.keychainHoleSize + 3) / 2;
  const circleLeft  = -state.keychainHoleOffset - 3 - outerR;
  const circleRight = -state.keychainHoleOffset - 3 + outerR;
  const tabLeft     = -state.keychainHoleOffset - 4;
  const tabRight    = tabLeft + (7 + state.keychainHoleOffset);

  const bbox = {
    minX: Math.min(base.x, circleLeft, tabLeft),
    maxX: Math.max(base.x + base.w, circleRight, tabRight),
    minY: Math.min(base.y, -outerR),
    maxY: Math.max(base.y + base.h, outerR)
  };

  return { base, dots, shift, bbox };
}

/* -------------------------- SVG preview -------------------------- */
function renderSVG(parsed) {
  const gBG = $('#bg'), gTXT = $('#txt'), gShapes = $('#shapes');
  gBG.innerHTML = ''; gTXT.innerHTML = ''; gShapes.innerHTML = '';

  if (state.renderStyle === 'braille') {
    const { base, dots, shift } = layoutBraille(parsed);

    // Rounded-rect base
    const rr = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    rr.setAttribute('d', roundRectPath(mm2px(base.x), mm2px(base.y), mm2px(base.w), mm2px(base.h), mm2px(BRAILLE_CFG.cornerR)));
    rr.setAttribute('fill', 'var(--bubble)');
    gShapes.appendChild(rr);

    // Keychain tab (outer pad + rect)
    const padR = (state.keychainHoleSize + 3) / 2;
    const padCx = mm2px(-state.keychainHoleOffset - 3);
    const padEl = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    padEl.setAttribute('cx', padCx);
    padEl.setAttribute('cy', 0);
    padEl.setAttribute('r', mm2px(padR));
    padEl.setAttribute('fill', 'var(--bubble)');
    gShapes.appendChild(padEl);

    const rectX = mm2px(-state.keychainHoleOffset - 4);
    const rectY = mm2px(-state.keychainHoleSize/2 - 1.25);
    const rectW = mm2px(7 + state.keychainHoleOffset);
    const rectH = mm2px(state.keychainHoleSize + 2.5);
    const rectEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectEl.setAttribute('x', rectX);
    rectEl.setAttribute('y', rectY);
    rectEl.setAttribute('width', rectW);
    rectEl.setAttribute('height', rectH);
    rectEl.setAttribute('fill', 'var(--bubble)');
    gShapes.appendChild(rectEl);

    // Dots (centered inside base)
    const r = BRAILLE_CFG.dotDiameter/2;
    for (const d of dots) {
      const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      c.setAttribute('cx', mm2px(d.x + shift.x));
      c.setAttribute('cy', mm2px(d.y + shift.y));
      c.setAttribute('r', mm2px(r));
      c.setAttribute('fill', '#000');
      gTXT.appendChild(c);
    }

  } else {
    // TEXT STYLE
    const fam = 'Arial, sans-serif';
    const fontPx = mm2px(state.fontSize);
    const rpx = mm2px(state.r);
    const bubbleStroke = 2 * rpx;

    const makeText = (str, x, y, forBubble=false) => {
      const el = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      el.setAttribute('x', x); el.setAttribute('y', y);
      el.setAttribute('dominant-baseline', 'middle');
      el.setAttribute('text-anchor', 'start');
      el.setAttribute('font-family', fam);
      el.setAttribute('font-size', fontPx);
      el.setAttribute('font-style', 'normal');
      el.setAttribute('font-weight', '400');
      el.textContent = str;
      if (forBubble) {
        el.setAttribute('fill', 'none');
        el.setAttribute('stroke', 'var(--bubble)');
        el.setAttribute('stroke-width', bubbleStroke);
        el.setAttribute('stroke-linejoin', 'round');
        el.setAttribute('stroke-linecap', 'round');
        el.style.paintOrder = 'stroke fill';
      } else {
        el.setAttribute('fill', '#000000');
      }
      return el;
    };

    // Line 1
    gBG.appendChild(makeText(parsed.name, 0, 0, true));
    gTXT.appendChild(makeText(parsed.name, 0, 0, false));

    // Line 2 (below line 1)
    if (parsed.second) {
      const x2 = mm2px(state.line2Offset);
      const y2 = mm2px(state.line2VerticalOffset);
      gBG.appendChild(makeText(parsed.line2, x2, y2, true));
      gTXT.appendChild(makeText(parsed.line2, x2, y2, false));
    }

    // Keychain tab
    const padR = (state.keychainHoleSize + 3) / 2;
    const padCx = mm2px(-state.keychainHoleOffset - 3);
    const padEl = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    padEl.setAttribute('cx', padCx);
    padEl.setAttribute('cy', 0);
    padEl.setAttribute('r', mm2px(padR));
    padEl.setAttribute('fill', 'var(--bubble)');
    gShapes.appendChild(padEl);

    const rectX = mm2px(-state.keychainHoleOffset - 4);
    const rectY = mm2px(-state.keychainHoleSize/2 - 1.25);
    const rectW = mm2px(7 + state.keychainHoleOffset);
    const rectH = mm2px(state.keychainHoleSize + 2.5);
    const rectEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rectEl.setAttribute('x', rectX);
    rectEl.setAttribute('y', rectY);
    rectEl.setAttribute('width', rectW);
    rectEl.setAttribute('height', rectH);
    rectEl.setAttribute('fill', 'var(--bubble)');
    gShapes.appendChild(rectEl);

    // Optional box
    if (state.boxWidth > 0 && state.boxHeight > 0) {
      const b = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      b.setAttribute('x', mm2px(state.boxXOffset));
      b.setAttribute('y', mm2px(state.boxYOffset));
      b.setAttribute('width', mm2px(state.boxWidth));
      b.setAttribute('height', mm2px(state.boxHeight));
      b.setAttribute('fill', 'var(--bubble)');
      gShapes.appendChild(b);
    }
  }

  const bbox = $('#gRoot').getBBox();
  $('#sz').textContent = `${px2mm(bbox.width).toFixed(1)}×${px2mm(bbox.height).toFixed(1)} mm · cell ${state.mmPerPixel} mm/px`;
  lastValid = { bg: gBG.innerHTML, txt: gTXT.innerHTML, shapes: gShapes.innerHTML, size: $('#sz').textContent };
}

/* SVG rounded-rect path (for preview) */
function roundRectPath(x, y, w, h, r) {
  const x2 = x + w, y2 = y + h;
  r = Math.min(r, w/2, h/2);
  return [
    `M ${x+r} ${y}`,
    `H ${x2-r}`,
    `A ${r} ${r} 0 0 1 ${x2} ${y+r}`,
    `V ${y2-r}`,
    `A ${r} ${r} 0 0 1 ${x2-r} ${y2}`,
    `H ${x+r}`,
    `A ${r} ${r} 0 0 1 ${x} ${y2-r}`,
    `V ${y+r}`,
    `A ${r} ${r} 0 0 1 ${x+r} ${y}`,
    'Z'
  ].join(' ');
}

/* ---------------------- Text measurement (DPI-independent) ---------------------- */
const _measureCanvas = document.createElement('canvas');
const _mctx = _measureCanvas.getContext('2d');

function measureTextMm(str, fontSizeMm, family='Arial, sans-serif') {
  const px = mm2px(fontSizeMm);
  _mctx.font = `normal normal ${px}px ${family}`;
  const wpx = _mctx.measureText(str).width || 0;
  return px2mm(wpx); // cancels DPI
}

/**
 * Compute a conservative mm-space bbox for Text style (two-line layout).
 * Returns {minX, minY, maxX, maxY} in mm including bubble radius and tab extents.
 */
function computeTextExportBBoxMm(parsed, state) {
  const fam = 'Arial, sans-serif';
  const fs = state.fontSize;

  const w1 = measureTextMm(parsed.name, fs, fam);
  const w2 = parsed.second ? measureTextMm(parsed.line2, fs, fam) : 0;

  // Line height ≈ 1.2 * font size (conservative)
  const lineH = fs * 1.2;

  // Line 1 centered at y=0; Line 2 at offsets
  let minX = 0, maxX = w1, minY = -lineH/2, maxY = lineH/2;

  if (parsed.second) {
    const x2 = state.line2Offset;
    const y2 = state.line2VerticalOffset;
    minX = Math.min(minX, x2);
    maxX = Math.max(maxX, x2 + w2);
    minY = Math.min(minY, y2 - lineH/2);
    maxY = Math.max(maxY, y2 + lineH/2);
  }

  // Bubble offset
  minX -= state.r; maxX += state.r;
  minY -= state.r; maxY += state.r;

  // Include tab & outer pad
  const outerR = (state.keychainHoleSize + 3) / 2;
  const circleCx = -state.keychainHoleOffset - 3;
  const tabLeft  = -state.keychainHoleOffset - 4;
  const tabRight = tabLeft + (7 + state.keychainHoleOffset);

  minX = Math.min(minX, circleCx - outerR, tabLeft);
  maxX = Math.max(maxX, circleCx + outerR, tabRight);
  minY = Math.min(minY, -outerR);
  maxY = Math.max(maxY,  outerR);

  // Optional box
  if (state.boxWidth > 0 && state.boxHeight > 0) {
    minX = Math.min(minX, state.boxXOffset);
    maxX = Math.max(maxX, state.boxXOffset + state.boxWidth);
    minY = Math.min(minY, state.boxYOffset);
    maxY = Math.max(maxY, state.boxYOffset + state.boxHeight);
  }

  // Small safety margin
  const s = 0.5;
  return { minX: minX - s, minY: minY - s, maxX: maxX + s, maxY: maxY + s };
}

/* ---------------------- Export canvases (FIXED resolution) ---------------------- */
function buildCanvasesForExport(parsed) {
  const res = state.mmPerPixel;       // FIXED: no auto-scaling
  const ppx = 1 / res;

  if (state.renderStyle === 'braille') {
    const L = layoutBraille(parsed);
    const wmm = L.bbox.maxX - L.bbox.minX;
    const hmm = L.bbox.maxY - L.bbox.minY;

    const W = Math.max(4, Math.ceil(wmm * ppx)) + 4;
    const H = Math.max(4, Math.ceil(hmm * ppx)) + 4;

    const base = document.createElement('canvas');
    base.width = W; base.height = H;
    const cxB = base.getContext('2d', { willReadFrequently: true });
    cxB.imageSmoothingEnabled = false;

    // Origin in mm so STL domes can align 1:1
    const originMmX = -L.bbox.minX;
    const originMmY = -L.bbox.minY;

    cxB.save();
    cxB.translate(originMmX * ppx, originMmY * ppx);
    cxB.fillStyle = '#ffffff';

    // Rounded rect base
    pathRoundRect_mm(cxB, L.base.x, L.base.y, L.base.w, L.base.h, BRAILLE_CFG.cornerR, ppx);
    cxB.fill();

    // Tab + outer pad
    cxB.fillRect(
      (-state.keychainHoleOffset - 4) * ppx,
      (-state.keychainHoleSize/2 - 1.25) * ppx,
      (7 + state.keychainHoleOffset) * ppx,
      (state.keychainHoleSize + 2.5) * ppx
    );
    cxB.beginPath();
    cxB.arc((-state.keychainHoleOffset - 3) * ppx, 0, (state.keychainHoleSize + 3)/2 * ppx, 0, Math.PI*2);
    cxB.closePath(); cxB.fill();

    // Inner hole (erase)
    cxB.globalCompositeOperation = 'destination-out';
    cxB.beginPath();
    cxB.arc((-state.keychainHoleOffset - 3) * ppx, 0, (state.keychainHoleSize)/2 * ppx, 0, Math.PI*2);
    cxB.closePath(); cxB.fill();

    // Optional box
    if (state.boxWidth > 0 && state.boxHeight > 0) {
      cxB.globalCompositeOperation = 'source-over';
      cxB.fillRect(
        state.boxXOffset * ppx,
        state.boxYOffset * ppx,
        state.boxWidth  * ppx,
        state.boxHeight * ppx
      );
    }

    cxB.restore();

    return { base, text: null, usedCell: res, braille: L, originMmX, originMmY };
  }

  // --- TEXT STYLE (DPI-independent sizing) ---
  const fam = 'Arial, sans-serif';
  const fs = state.fontSize;

  const bb = computeTextExportBBoxMm(parsed, state);
  const wmm = (bb.maxX - bb.minX), hmm = (bb.maxY - bb.minY);

  const W = Math.max(4, Math.ceil(wmm * ppx));
  const H = Math.max(4, Math.ceil(hmm * ppx));

  const base = document.createElement('canvas');
  const text = document.createElement('canvas');
  base.width = text.width = W;
  base.height = text.height = H;

  const cxB = base.getContext('2d', { willReadFrequently: true });
  const cxT = text.getContext('2d', { willReadFrequently: true });
  cxB.imageSmoothingEnabled = cxT.imageSmoothingEnabled = false;

  // origin so that bb.minX/minY maps to (0,0)
  const originX = -bb.minX * ppx;
  const originY = -bb.minY * ppx;

  const fontPx = fs * ppx;
  const fontCSS = `normal normal ${fontPx}px ${fam}`;

  // --- draw bubble & solids on base canvas ---
  cxB.save();
  cxB.translate(originX, originY);
  cxB.fillStyle = '#ffffff';
  cxB.strokeStyle = '#ffffff';
  cxB.lineJoin = 'round'; cxB.lineCap = 'round';
  cxB.font = fontCSS; cxB.textBaseline = 'middle'; cxB.textAlign = 'left';

  // text lines at mm positions (bubble via stroke dilation)
  cxB.lineWidth = 2 * state.r * ppx;
  cxB.strokeText(parsed.name, 0, 0);
  cxB.fillText(parsed.name, 0, 0);

  if (parsed.second) {
    cxB.strokeText(parsed.line2, state.line2Offset * ppx, state.line2VerticalOffset * ppx);
    cxB.fillText(parsed.line2, state.line2Offset * ppx, state.line2VerticalOffset * ppx);
  }

  // tab rect
  cxB.fillRect(
    (-state.keychainHoleOffset - 4) * ppx,
    (-state.keychainHoleSize/2 - 1.25) * ppx,
    (7 + state.keychainHoleOffset) * ppx,
    (state.keychainHoleSize + 2.5) * ppx
  );
  // outer circle
  cxB.beginPath();
  cxB.arc((-state.keychainHoleOffset - 3) * ppx, 0, (state.keychainHoleSize + 3)/2 * ppx, 0, Math.PI*2);
  cxB.closePath(); cxB.fill();

  // inner hole (erase)
  cxB.globalCompositeOperation = 'destination-out';
  cxB.beginPath();
  cxB.arc((-state.keychainHoleOffset - 3) * ppx, 0, (state.keychainHoleSize)/2 * ppx, 0, Math.PI*2);
  cxB.closePath(); cxB.fill();

  // optional box
  if (state.boxWidth > 0 && state.boxHeight > 0) {
    cxB.globalCompositeOperation = 'source-over';
    cxB.fillRect(
      state.boxXOffset * ppx,
      state.boxYOffset * ppx,
      state.boxWidth  * ppx,
      state.boxHeight * ppx
    );
  }
  cxB.restore();

  // --- raised text layer ---
  cxT.save();
  cxT.translate(originX, originY);
  cxT.fillStyle = '#ffffff';
  cxT.font = fontCSS; cxT.textBaseline = 'middle'; cxT.textAlign = 'left';
  cxT.fillText(parsed.name, 0, 0);
  if (parsed.second) {
    cxT.fillText(parsed.line2, state.line2Offset * ppx, state.line2VerticalOffset * ppx);
  }
  cxT.restore();

  return { base, text, usedCell: res, braille: null };
}

/* mm-based rounded-rect path into current 2D canvas context */
function pathRoundRect_mm(ctx, x_mm, y_mm, w_mm, h_mm, r_mm, ppx) {
  const x = x_mm*ppx, y = y_mm*ppx, w = w_mm*ppx, h = h_mm*ppx, r = Math.min(r_mm*ppx, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.arc(x+w-r, y+r, r, -Math.PI/2, 0);
  ctx.lineTo(x+w, y+h-r);
  ctx.arc(x+w-r, y+h-r, r, 0, Math.PI/2);
  ctx.lineTo(x+r, y+h);
  ctx.arc(x+r, y+h-r, r, Math.PI/2, Math.PI);
  ctx.lineTo(x, y+r);
  ctx.arc(x+r, y+r, r, Math.PI, 1.5*Math.PI);
  ctx.closePath();
}

/* ---------------------- Raster → Mesh → STL ---------------------- */
function canvasToMesh(canvas, cellMM, heightMM, z0) {
  const w = canvas.width, h = canvas.height;
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const img = ctx.getImageData(0,0,w,h).data;

  const filled = (x,y) => (x>=0 && y>=0 && x<w && y<h) ? img[(y*w + x)*4 + 3] > 0 : false;
  const tris = [];

  function emitTopBottom(ix, iy) {
    const x0 = ix * cellMM, y0 = -iy * cellMM;
    const x1 = x0 + cellMM, y1 = y0 - cellMM;
    const zt = z0 + heightMM, zb = z0;
    tris.push([[x0,y0,zt],[x1,y0,zt],[x1,y1,zt]]);
    tris.push([[x0,y0,zt],[x1,y1,zt],[x0,y1,zt]]);
    tris.push([[x0,y0,zb],[x1,y1,zb],[x1,y0,zb]]);
    tris.push([[x0,y0,zb],[x0,y1,zb],[x1,y1,zb]]);
  }
  function emitSide(p0, p1) {
    const [x0,y0]=p0,[x1,y1]=p1; const zb=z0, zt=z0+heightMM;
    tris.push([[x0,y0,zb],[x1,y1,zb],[x1,y1,zt]]);
    tris.push([[x0,y0,zb],[x1,y1,zt],[x0,y0,zt]]);
  }

  for (let y=0; y<h; y++) {
    for (let x=0; x<w; x++) {
      if (!filled(x,y)) continue;
      emitTopBottom(x,y);
      if (!filled(x-1,y)) emitSide([x*cellMM, -y*cellMM],[x*cellMM, -(y+1)*cellMM]);
      if (!filled(x+1,y)) emitSide([(x+1)*cellMM, -(y+1)*cellMM],[(x+1)*cellMM, -y*cellMM]);
      if (!filled(x,y-1)) emitSide([(x+1)*cellMM, -y*cellMM],[x*cellMM, -y*cellMM]);
      if (!filled(x,y+1)) emitSide([x*cellMM, -(y+1)*cellMM],[(x+1)*cellMM, -(y+1)*cellMM]);
    }
  }
  return tris;
}

function trianglesToBinarySTL(tris) {
  const triCount = tris.length;
  const buffer = new ArrayBuffer(84 + 50 * triCount);
  const dv = new DataView(buffer);
  let off = 0;
  for (let i=0;i<80;i++) dv.setUint8(off++,0);
  dv.setUint32(off, triCount, true); off+=4;
  function normal(a,b,c){ const ux=b[0]-a[0],uy=b[1]-a[1],uz=b[2]-a[2];
    const vx=c[0]-a[0],vy=c[1]-a[1],vz=c[2]-a[2];
    return [uy*vz-uz*vy, uz*vx-ux*vz, ux*vy-uy*vx];
  }
  for (const t of tris) {
    const [a,b,c]=t, n=normal(a,b,c);
    dv.setFloat32(off,n[0],true); off+=4;
    dv.setFloat32(off,n[1],true); off+=4;
    dv.setFloat32(off,n[2],true); off+=4;
    for (const p of [a,b,c]) { dv.setFloat32(off,p[0],true); off+=4; dv.setFloat32(off,p[1],true); off+=4; dv.setFloat32(off,p[2],true); off+=4; }
    dv.setUint16(off,0,true); off+=2;
  }
  return new Blob([buffer], {type:'application/octet-stream'});
}

/* Add spherical-cap dome triangles at (cx,cy) sitting on base plane z0 */
function addDome(tris, cx, cy, z0, baseRadius, capHeight, segs=BRAILLE_CFG.domeSegs, rings=BRAILLE_CFG.domeRings) {
  const a = baseRadius, h = capHeight;
  const R = (a*a + h*h) / (2*h);     // sphere radius
  const zc = z0 + h - R;             // sphere center z
  const thetaBase = Math.acos((R - h)/R);
  const TWO_PI = Math.PI*2;

  const thetas = [];
  for (let i=0; i<=rings; i++) thetas.push(thetaBase * (i / rings));

  for (let ri=0; ri<thetas.length-1; ri++) {
    const t0 = thetas[ri], t1 = thetas[ri+1];
    const r0 = R * Math.sin(t0), z0ring = zc + R * Math.cos(t0);
    const r1 = R * Math.sin(t1), z1ring = zc + R * Math.cos(t1);

    for (let si=0; si<segs; si++) {
      const a0 = (si / segs) * TWO_PI;
      const a1 = ((si+1) / segs) * TWO_PI;

      const x00 = cx + r0 * Math.cos(a0), y00 = cy + r0 * Math.sin(a0);
      const x01 = cx + r0 * Math.cos(a1), y01 = cy + r0 * Math.sin(a1);
      const x10 = cx + r1 * Math.cos(a0), y10 = cy + r1 * Math.sin(a0);
      const x11 = cx + r1 * Math.cos(a1), y11 = cy + r1 * Math.sin(a1);

      tris.push([[x00, -y00, z0ring], [x10, -y10, z1ring], [x11, -y11, z1ring]]);
      tris.push([[x00, -y00, z0ring], [x11, -y11, z1ring], [x01, -y01, z0ring]]);
    }
  }
}

/* -------------------------- Build STL -------------------------- */
function buildSTL(parsed) {
  const { base, text, usedCell, braille, originMmX, originMmY } = buildCanvasesForExport(parsed);
  const cell = usedCell;

  const tris = [];

  // Base mesh (raster → prism)
  const baseMesh = canvasToMesh(base, cell, state.thickness, 0);
  for (let i=0;i<baseMesh.length;i++) tris.push(baseMesh[i]);   // for-loop FIX (no spread)

  if (state.renderStyle === 'braille') {
    const dotR = BRAILLE_CFG.dotDiameter / 2;
    const h = BRAILLE_CFG.dotHeight;
    const z0 = state.thickness;

    // align domes to raster base using origin and centering shift (mm)
    const ox = (originMmX || 0) + braille.shift.x;
    const oy = (originMmY || 0) + braille.shift.y;

    for (const d of braille.dots) {
      addDome(tris, ox + d.x, oy + d.y, z0, dotR, h);
    }
  } else {
    const txtH = state.facedownMode ? 0.1 : state.textThickness;
    if (text && txtH > 0) {
      const textMesh = canvasToMesh(text, cell, txtH, state.thickness);
      for (let i=0;i<textMesh.length;i++) tris.push(textMesh[i]); // for-loop FIX (no spread)
    }
  }

  const blob = trianglesToBinarySTL(tris);
  const namePart = (parsed.second ? `${parsed.name}_${parsed.line2}` : parsed.name).replace(/\s+/g,'_');
  const fn = `keychain_${namePart}_${state.renderStyle}_${state.fontSize}mm_r${state.r}_hole${state.keychainHoleSize}.stl`;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = fn;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

/* -------------------------- App flow -------------------------- */
function applyAll() {
  state.renderStyle = renderStyleSel.value;
  state.fontFamily = hiddenFontFamily.value; // "Arial"
  readAdvancedIntoState();

  const parsed = parseKeychainText(inputText.value);
  if (!parsed.ok) { setError(parsed.reason); return; }
  clearError();

  renderSVG(parsed);
  history.replaceState(null,'', paramsToQuery());
}

function resetAll() {
  inputText.value = '';
  state = {...DEFAULTS};
  renderStyleSel.value = state.renderStyle;
  hiddenFontFamily.value = state.fontFamily;
  initAdvancedFromState();
  clearError();

  if (!lastValid) {
    $('#bg').innerHTML = '';
    $('#txt').innerHTML = '';
    $('#shapes').innerHTML = '';
    $('#sz').textContent = '—';
  }
  history.replaceState(null,'', paramsToQuery());
}

function boot() {
  parseQuery();
  initAdvancedFromState();
  renderStyleSel.value = state.renderStyle;
  hiddenFontFamily.value = state.fontFamily;

  applyAll();

  inputText.addEventListener('input', applyAll);
  renderStyleSel.addEventListener('input', applyAll);
  $('#btnReset').addEventListener('click', resetAll);
  $('#btnDownload').addEventListener('click', () => {
    const parsed = parseKeychainText(inputText.value);
    if (!parsed.ok) { setError(parsed.reason); return; }
    try {
      buildSTL(parsed);
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      setError('Export failed. Try a smaller design. (' + msg + ')');
    }
  });
}

document.addEventListener('DOMContentLoaded', boot);
</script>
</body>
</html>
